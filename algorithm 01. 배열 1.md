# 1. 알고리즘

- 알고리즘
    - 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
    - 컴퓨터가 어떠한 문제를 해결하기 위한 절차
- 알고리즘 표현 방법 (컴퓨터 분야)
    - 의사코드 (Pseudocode, 슈도코드)
    - 순서도
- 시간복잡도
    - 알고리즘의 성능은 시간복잡도로 표현
    - 빅-오 표기법
        - 계수는 생략하고 가장 큰 영향력을 주는 n에 대한 항만을 표시

# 2. 배열

- 배열이란
    - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
    - ex. 6개의 변수 대신 6개의 원소를 가진 배열로 바꾸어 사용
- 배열의 필요성
    - 프로그램 내에서 여러 개의 변수가 필요할 때 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적
    - 하나의 선언을 통해 둘 이상의 변수 선언 가능
    - 다수의 변수로는 하기 힘든 작업 쉽게 할 수 있음
- 1차원 배열의 선언
    - `arr = list()`
    - `arr = []`
    - `arr = [1, 2, 3]`
    - `arr = [0] * 10`

## 2.1. 연습 문제 : Gravity

```python
T = int(input())
for t in range(T) :
    n = int(input())
    box = [int(b) for b in input().split()]
    box.append(101)  # 안 해도 되는데???

    maxfall = 0
    for i in range(n) :
        fall = 0
        for j in range(i + 1, n + 1) :
            if box[i] > box[j] :
                fall += 1
        if fall > maxfall :
            maxfall = fall

    print(f'#{t + 1} {maxfall}')
```

# 3. 정렬

- 대표적인 정렬 알고리즘
  
  
    | 알고리즘 | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고 |
    | --- | --- | --- | --- | --- |
    | 버블 정렬 | O(n²) | O(n²) | 비교와 교환 | 코딩이 가장 손쉬움 |
    | 카운팅 정렬 | O(n + k) | O(n + k) | 비교환 | n이 비교적 작을 때만 가능 |
    | 선택 정렬 | O(n²) | O(n²) | 비교와 교환 | 교환의 횟수가 버블, 삽입 정렬보다 적음 |
    | 퀵 정렬 | O(n log n) | O(n²) | 분할 정복 | 최악의 경우 O(n²)이지만 평균적으로는 가장 빠름 |
    | 삽입 정렬 | O(n²) | O(n²) | 비교와 교환 | n의 개수가 작을 때 효과적 |
    | 병합 정렬 | O(n log n) | O(n log n) | 분할 정복 | 연결 리스트의 경우 가장 효율적 |

## 3.1. 버블 정렬

- 버블 정렬
    - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
    - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 함
- 과정
    - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
    - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬됨
    - 반복
- 시간 복잡도
    - O(n²)
- 코드 구현
  
    ```python
    def BubbleSort(a, N):  # 정렬할 리스트, 원소 수
        for i in range(N - 1, 0, -1):  # 범위의 끝 위치
    	      for j in range(i):
                if a[j] > a[j + 1]:
                    a[j], a[j + 1] = a[j + 1], a[j]
    ```
    

## 3.2. 카운팅 정렬

- 카운팅 정렬
    - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 통해 선형 시간에 정렬하는 효율적인 알고리즘
- 제한 사항
    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
        - 각 항목의 발생 회수를 기록하기 위해 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
- 과정
    - data에서의 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장
    - 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 누적 합계로 조정
    - data의 맨 뒤부터 순회하며 data[-1]의 값이 1이라면  count[1]의 값을 1 감소시키고 그 값을 인덱스로 하는 위치 temp[count[1]]에 1을 삽입
    - data의 맨 앞까지 반복
- 시간 복잡도
    - O(n + k) : n은 리스트 길이, k는 정수의 최대값
- 코드 구현
  
    ```python
    def CountingSort(A, B, k):
        # A : 입력 배열 (1 to k)
        # B : 정렬된 배열
        # C : 카운트 배열
    
        C = [0] * (k + 1)
    
        for i in range(len(A)):
            C[A[i]] += 1
        
        for i in range(1, len(C)):
            C[i] += C[i - 1]
    
        for i in range(len(B) - 1, -1, -1):
            C[A[i]] -= 1
            B[C[A[i]]] = A[i]
        
        return B
    ```
    

# 3. 알고리즘

## 3.1. 완전 검색

- 완전 검색
    - 모든 경우의 수를 확인하는 기법 (경우의 수가 적을 때 유용)
    - 수행 속도는 느리지만 해답을 찾아내지 못할 확률이 작음
    - Brute-force, Generate-and-test 기법

### 3.1.1. 연습 문제 : Baby-gin game

- 완전 검색을 활용한 Baby-gin 접근
    - 6개의 숫자로 만들 수 있는 모든 숫자 나열 (중복 포함)
    - 앞과 뒤 3자리를 잘라 run과 triplet 여부를 테스트하고 최종 판단
- 순열 (Permutation)
    - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
    - {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
        - 동일한 숫자가 포함되지 않았을 때만 가능한 방식
        
        ```python
        for i1 in range(1, 4):
            for i2 in range(1, 4):
                if i2 != i1:
                    for i3 in range(1, 4):
                        if i3 != i1 and i3 != i2:
                            print(i1, i2, i3)
        ```
        

## 3.2. 그리디 알고리즘

- 그리디 알고리즘
    - 탐욕 알고리즘은 최적 해를 구하는 데 사용되는 근시안적인 방법
    - 여러 경우 중 하나를 결정해야 할 때마다 그 순간 최적이라고 생각되는 것을 선택하는 방식으로 최종 해답에 도달
    - 결정들이 지역적으로는 최적이지만 최종 해답까지 최적이라는 보장은 없음
- 동작 과정
    - 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤 이를 부분해 집합에 추가
    - 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인 (제약 조건을 위반하지 않는지)
    - 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지 확인. 완성되지 않았다면 1부터 다시 시작

### 3.2.1. 연습 문제 : Baby-gin game

- 그리디 알고리즘을 활용한 Baby-gin 접근
    - 정수로 입력되는 입력값을 counts 배열로 만들어 run과 triplet 여부 확인
- 코드 구현
  
    ```python
    num = 456789  # baby-gin 확인할 수
    c = [0] * 12  # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트
    
    for i in range(6):
        c[num % 10] += 1
        num //= 10
    
    i = 0
    tri = run = 0
    while i < 10:
        if c[i] >= 3:  # triplet 조사 후 데이터 삭제
            c[i] -= 3
            tri += 1
            continue
        if c[i] >= 1 and c[i + 1] >= 1 and c[i + 2] >= 1:  # run 조사 후 데이터 삭제
            c[i] -= 1
            c[i + 1] -= 1
            c[i + 2] -= 1
            run += 1
            continue
        i += 1
    
    if run + tri == 2:
        print("Baby-Gin")
    else:
        print("Lose")
    ```
    
- 자주 실수하는 오답
    - 숫자를 정렬한 후 앞뒤 3자리씩 끊어서 확인하는 방법
        - 644544 → 444456 : 쉽게 확인 가능
        - 123123 → 112233 : 오히려 확인 실패할 수 있음
    - 이처럼 해답을 찾아내지 못하는 경우도 있으니 유의해야 함