### 1. 복잡도 분석

- 알고리즘의 효율
    - 공간적 효율성 : 연산량 대비 얼마나 적은 메모리 공간을 요하는가
    - 시간적 효율성 : 연산량 대비 얼마나 적은 시간을 요하는가
    - 효율성 ↔ 복잡도 (복잡도가 높을수록 효율성은 저하)
- 시간적 복잡도 분석
    - 하드웨어 환경에 따라 처리시간이 달라짐
        - 부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무
        - 입출력 장비의 성능, 공유 여부
    - 소프트웨어 환경에 따라 처리시간이 달라짐
        - 프로그램 언어의 종류
        - 운영체제, 컴파일러의 종류
    - 위와 같은 환경적 차이로 인해 분석이 어려움
- 복잡도의 점근적 표기
    - 시간 또는 공간 복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식
    - 이를 단순한 함수로 표현하기 위해 점근적 표기(Asymptotic Notation) 사용
    - 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현
        - O(Big-Oh)-표기
        - Ω(Big-Omega)-표기
        - θ(Big-Theta)-표기
- O(Big-Oh)-표기
    - 복잡도의 점근적 상한을 나타냄
    - 복잡도가 $f(n) = 2n^2 - 7n + 4$이라면, O-표기는 $O(n^2)$
    - 단순화된 함수 $n^2$에 임의의 상수 $c$를 곱한 $cn^2$이 $n$이 증가함에 따라 $f(n)$의 상한이 됨 (단, $c > 0$)
    - $O(n^2)$ : 실행시간이 $n^2$에 비례하는 알고리즘
- Ω(Big-Omega)-표기
    - 복잡도의 점근적 하한을 나타냄
    - 복잡도가 $f(n) = 2n^2 - 7n + 4$이라면, Ω-표기는 $Ω(n^2)$
    - $n$이 증가함에 따라 $2n^2 - 7n + 4$이 $cn^2$보다 작을 수 없음 (상수 $c = 1$)
    - $Ω(n^2)$ : 최소한 이만한 시간은 걸림
- θ(Big-Theta)-표기
    - O-표기와 Ω-표기가 같은 경우 사용
    - $f(n) = 2n^2 + 8n + 3 = O(n^2) = Ω(n^2)$이므로 $f(n) = Ω(n^2)$
    - $θ(n^2)$ : $f(n)$은 $n$이 증가함에 따라 $n^2$과 동일한 증가율을 가짐
- 자주 사용하는 O-표기
    - $O(1)$ : 상수 시간
    - $O(\log n)$ : 로그(대수) 시간
    - $O(n)$ : 선형 시간
    - $O(n\log n)$ : 로그 선형 시간
    - $O(n^2)$ : 제곱 시간
    - $O(n^3)$ : 세제곱 시간
    - $O(2^n)$ : 지수 시간

### 2. 표준 입출력 방법

- python3 표준 입력
    - `input()` : raw 값의 입력
        - 받은 입력값을 문자열로 취급
    - `eval(input())` : evaluated된 값 입력
        - 받은 입력값을 평가된 데이터 형으로 취급
        - ex. 산술 연산을 전달하면 계산하고, 함수 이름을 전달하면 함수 호출
- python3 표준 출력
    - `print()` : 표준 출력 함수. 출력값의 마지막에 개행 문자 포함
    - `print('text', end = '')` : 출력 시 마지막 개행 문자 제외
    - `print('%d' % number)` : formatting 된 출력
- 파일의 내용을 표준 입력으로 읽어오는 방법
  
    ```python
    import sys
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
    
    text = input()
    print(text)
    ```
    

### 3. 비트 연산

- 비트 연산자
    - `&` : 비트 단위로 AND 연산
    - `|` : 비트 단위로 OR 연산
    - `^` : 비트 단위로 XOR 연산 (같으면 0, 다르면 1)
    - `~` : 단항 연산자로서 피연산자의 모든 비트 반전
    - `<<` : 피연산자의 비트 열을 왼쪽으로 이동
    - `>>` : 피연산자의 비트 열을 오른쪽으로 이동
- `1 << n`
    - $2^n$의 값을 가짐
    - 원소가 n개일 경우의 모든 부분집합의 수
        - Power set (모든 부분집합)
            - 공집합과 자기 자신을 포함한 모든 부분집합
            - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산됨
- `i & (1 << j)`
    - 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미
- 연습문제
    - 0과 1로 이루어진 1차 배열에서 7개 bit를 묶어서 10진수로 출력
      
        ```python
        T = int(input())
        for _ in range(T):
            b = input()
            i = 0
            while i < len(b):
                sub_b = b[i:i + 7]
                d = 0
                for j in range(len(sub_b)):
                    d += int(sub_b[len(sub_b) - 1 - j]) * (2 ** j)
                print(d, end = ' ')
                i += 7
            print()
        ```
    
- 엔디안 (Endianness)
    - 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW 아키텍처마다 다름
    - 주의! 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산할 때 올바로 이해하지 않으면 오류를 발생시킬 수 있음
    - 종류
        - 빅 엔디안 : 큰 단위가 앞에 나옴 (네트워크)
        - 리틀 엔디안 : 작은 단위가 앞에 나옴 (대다수 데스크탑 컴퓨터)
        
        | 종류 | 0x1234의 표현 | 0x12345678의 표현 |
        | --- | --- | --- |
        | 빅 엔디안 | 12 34 | 12 34 56 78 |
        | 리틀 엔디안 | 34 12 | 78 56 34 12 |
    - 엔디안 확인 코드
      
        ```python
        import sys
        print(sys.byteorder) # little
        ```
    
- 비트 연산 예제
  
    ```python
    def Bbit_print(i):
        output = ''
        for j in range(7, -1, -1):
            output += '1' if i & (1 << j) else '0'
        print(output)
    
    for i in range(-5, 6):
        print('%3d = ' % i, end = '')
        Bbit_print(i)
    
    '''
    -5 = 11111011
    -4 = 11111100
    -3 = 11111101
    -2 = 11111110
    -1 = 11111111
     0 = 00000000
     1 = 00000001
     2 = 00000010
     3 = 00000011
     4 = 00000100
     5 = 00000101
    '''
    ```
    
    ```python
    def Bbit_print(i):
        output = ''
        for j in range(7, -1, -1):
            output += '1' if i & (1 << j) else '0'
        print(output, end = ' ')
    
    a = 0x10
    x = 0x01020304
    print('%d = ' % a, end = '')
    Bbit_print(a)
    print()
    print('0%x = ' % x, end = '')
    for i in range(0, 4):
        Bbit_print((x >> i * 8) & 0xff)
    
    '''
    16 = 00010000 
    01020304 = 00000100 00000011 00000010 00000001
    '''
    ```
    
    ```python
    def ce(n): # change endian
        p = []
        for i in range(0, 4):
            p.append((n >> (24 - i * 8)) & 0xff)
        return p
    
    x = 0x01020304
    p = []
    for i in range(0, 4):
        p.append((x >> (i * 8)) & 0xff)
    
    print('x = %d%d%d%d' % (p[0], p[1], p[2], p[3])) # x = 4321
    p = ce(x)
    print('x = %d%d%d%d' % (p[0], p[1], p[2], p[3])) # x = 1234
    ```
    
    ```python
    def ce1(n):
        return (n << 24 & 0xff000000) | (n << 8 & 0xff0000) | (n >> 8 & 0xff00) | (n >> 24 & 0xff)
    
    x = 0x01020304
    print(ce1(x)) # 67305985 (16진수로 04030201)
    ```
    
    ```python
    # 비트 연산자 ^를 두 번 연산하면 처음 값 반환
    
    def Bbit_print(i):
        output = ''
        for j in range(7, -1, -1):
            output += '1' if i & (1 << j) else '0'
        print(output)
    a = 0x86
    key = 0xAA
    
    print('a\t : ', end = '')
    Bbit_print(a)
    
    print('key\t : ', end = '')
    Bbit_print(key)
    
    print('a ^= key : ', end = '')
    a ^= key
    Bbit_print(a)
    
    print('a ^= key : ', end = '')
    a ^= key
    Bbit_print(a)
    
    '''
    a        : 10000110
    key      : 10101010
    a ^= key : 00101100
    a ^= key : 10000110
    '''
    ```
    

### 4. 진수

- 10진수에서 타 진수로 변환
    - 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.
    - ex. 149(10) = 10010101(2) = 225(8) = 95(16)
- 타 진수에서 10진수로 변환
    - ex. $135_8 = 1 * 8^2 + 3 * 8^1 + 5 * 8^0 = 93_{10}$
    - ex. (소수점 있는 경우) $135.12_8 = 1 * 8^2 + 3 * 8^1 + 5 * 8^0 + 1 * 8^{-1} + 2 * 8^{-2} = 93.15625_{10}$
- 2진수, 8진수, 16진수 간 변환
    - 2진법 ↔ 8진법 : 3자리씩 묶음/나열
    - 2진법 ↔ 16진법 : 4자리씩 묶음/나열
- 컴퓨터에서의 음의 정수 표현 방법
    - 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환
        - -6 : 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 (부호와 절대값 표현)
        - -6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 (1의 보수 표현)
    - 2의 보수 : 1의 보수 방법으로 표현된 값의 최하위 비트에 1 더함
        - -6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 (2의 보수 표현)
- 연습문제
    - 16진수 문자로 이루어진 1차 배열이 주어질 때 앞에서부터 7bit씩 묶어 십진수로 변환하여 출력
      
        ```python
        def h_to_b(h):
            char = '0123456789ABCDEF'
            b = ''
            for i in range(len(h)):
                sub_b = ''
                for num in range(len(char)):
                    if h[i] == char[num]:
                        for _ in range(4):
                            sub_b = str(num % 2) + sub_b
                            num //= 2
                        break
                b += sub_b
            return b
        
        def b_to_d(b):
            i = 0
            while i < len(b):
                sub_b = b[i:i + 7]
                d = 0
                for j in range(len(sub_b)):
                    d += int(sub_b[len(sub_b) - 1 - j]) * (2 ** j)
                print(d, end = ' ')
                i += 7
        
        T = int(input())
        for _ in range(T):
            h = input()
            b_to_d(h_to_b(h))
            print()
        ```
        

### 5. 실수

- 실수의 표현
    - 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법 사용
        - 소수점의 위치를 고정시켜 표현하는 방식
        - 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑 수의 지수 승으로 표현
- 실수 저장 형식
    - 단정도 실수 (32비트)
        - 부호 1비트 + 지수 8비트 + 가수 23비트
    - 배정도 실수 (64비트)
        - 부호 1비트 + 지수 11비트 + 가수 52비트
- 가수부 & 지수부
    - 가수부(mantissa) : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
    - 지수부(exponent) : 실제 소수점의 위치를 지수 승으로 표현한 것
- 단정도 실수 표현 예시
    - 단정도 실수의 가수 부분을 만드는 방법
        - ex. $1001.0011$
            - 정수부의 첫 번째 자리가 1이 되도록 오른쪽으로 시프트
                - $0001.0010011$
            - 소수점 이하를 23비트로 만듦
                - $0001.00100110000000000000000$
            - 소수점 이하만을 가수 부분에 저장
                - $00100110000000000000000$
            - 지수 부분은 시프트한 자릿수만큼 증가 또는 감소
                - $1.0010011 \times 2 ^3$
    - 단정도 실수의 지수 부분을 만드는 방법
        - 지수부에는 8비트가 배정 (256개의 상태를 나타낼 수 있음)
        - 숫자로는 0~255까지 나타낼 수 있지만, 음수 값을 나타낼 수 있어야 하므로 익세스 표현법 사용
            - 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수 지수와 양수 지수를 표현하는 방법
    - 1001.0011을 단정도 실수로 표현한 예
      
      
        | 0 | 10000010 | 00100110000000000000000 |
        | --- | --- | --- |
- 실수의 오차
    - 컴퓨터는 실수를 근사적으로 표현
        - 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사 값으로 저장되는데, 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴
    - 실수 자료형의 유효 자릿수
        - 32비트 : 6
        - 64비트 : 15
- 파이썬 실수 표현 범위
    - 파이썬에서는 내부적으로 더 많은 비트를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있음
    - 최대로 표현할 수 있는 값은 약 $1.8 \times 10^{308}$이고 이 이상은 inf로 표현
    - 최소로 표현할 수 있는 값은 약 $5.0 \times 10^{-324}$이며 이 이하는 0으로 표현
- 연습문제
    - 16진수 문자로 이루어진 1차 배열이 주어질 때 암호비트패턴을 찾아 차례로 출력
      
        ```python
        pattern = {
            '001101' : 0,
            '010011' : 1,
            '111011' : 2,
            '110001' : 3,
            '100011' : 4,
            '110111' : 5,
            '001011' : 6,
            '111101' : 7,
            '011001' : 8,
            '101111' : 9
        }
        
        T = int(input())
        for _ in range(T):
            char = '0123456789ABCDEF'
            h = input()
            b = ''
            for i in range(len(h)):
                sub_b = ''
                for num in range(len(char)):
                    if h[i] == char[num]:
                        for _ in range(4):
                            sub_b = str(num % 2) + sub_b
                            num //= 2
                        break
                b += sub_b
            
            j = 0
            while j < len(b):
                if b[j:j + 6] in pattern:
                    print(pattern[b[j:j + 6]], end = ' ')
                    j += 6
                else:
                    j += 1
            print()
        ```