## 1. UX & UI

- 개요
    - 우리는 비슷한 것끼리 묶거나 내용을 구성해서 인지하는 것이 편하다는 것을 알고 있다. 만약 그렇지 않을 경우 불편하다는 느낌을 받거나 의사결정을 하는데 많은 시간이 걸리기도 한다
    - 이러한 요소들은 유저와 밀접한 부분이기에 매우 중요하며 모든 서비스에서 반드시 고려되어야 한다.

### 1.1. UX & UI

- UX (User Experience)
    - ex. 데이터를 보니 사람들이 여기 있는 메뉴바를 잘 사용하지 않는 것 같아. 차라리 크기를 확 줄이거나 위치를 조정해보면 어떨까?
    - 유저와 가장 가까이에 있는 분야, 데이터를 기반으로 유저를 조사하고 분석해서 개발자, 디자이너가 이해할 수 있게 소통
    - 유저가 느끼는 느낌, 태도 그리고 행동을 디자인
        - ex. 백화점 1층 향수 향기, 러쉬 매장 근처 향기, 로딩이 길어서 사용하고 싶지 않은 사이트 등
- 좋은 UX를 설계하기 위해서는
    - 사람들의 마음과 생각을 이해하고 정리해서 우리 제품에 녹여내는 과정이 필요
    - 유저 리서치, 데이터 설계 및 정제, 유저 시나리오, 프로토타입 설계 등이 필요
- UI (User Interface)
    - ex. 메뉴바의 위치는 다른 구성 요소 배치와 함께 생각했을 때 여기가 좋겠어. 유저는 위에서부터 내려와서 여기에서 결정하는 시나리오를 따를 것 같아.
    - 유저에게 보여지는 화면을 디자인
    - UX를 고려한 디자인을 반영, 이 과정에서 기능 개선 혹은 추가가 필요한 경우 프론트엔드 개발자와 가장 많이 소통
- [참고] Interface
    - 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점
        - 즉, 사용자가 기기를 쉽게 동작시키는
- 좋은 UI를 설계하기 위해서는
    - 예쁜 디자인 즉 심미적인 부분만 중요하다기보다는 사용자가 보다 쉽고 편리하게 사용할 수 있도록 하는 부분까지 고려되어야 함
    - 통일된 디자인을 위한 디자인 시스템, 소통을 위한 중간 산출물, 프로토타입 등이 필요
    - UI 디자인에 있어 가장 중요한 것은 협업
- 디자이너와 기획자 그리고 개발자
    - 많은 회사에서 UX/UI 디자인을 함께하는 디자이너를 채용하거나 UX는 기획자, UI는 디자이너의 역할
    - UX (직무 : UX Researcher, User Researcher)
        - 구글 : 사용자의 경험을 이해하기 위한 통계 모델 설계
        - MS : 리서치를 기획하고 사용자에 대한 지표 정의
        - Meta : 정성적인 방법과 정량적인 방법을 사용해서 사용자 조사 실시
    - UI (직무 : Product Designer, Interaction Designer)
        - 구글 : 다양한 디자인 프로토타이핑 툴을 사용해서 개발 가이드를 제시
        - MS : 시각 디자인을 고려해서 체계적인 디자인 컨셉을 보여줌
    - 개발자는 단순히 기능 개발만 하는 사람이 아니며 제품에 대해 고민하고 소통하는 능력이 반드시 필요
    - 즉 다양한 분야와의 협업이 필수적이기에 기본적인 UX/UI에 대한 이해가 있어야 함

### 1.2. 생각하는 UX & UI 디자인

- 만약 유저에 대한 이해 없이 기능만을 생각한다면
    - UI 디자인은 너무나 깔끔하게 되었으나 UX를 고려하지 않아 유저들은 잔디밭 위로 지름길을 만들어 다녔고, 심지어 너무 많이 다녀서 잔디마저 모두 사라져버린 상황
    - UX/UI를 디자인하는 것은 굉장히 섬세하면서 어려운 작업
- [참고] Can’t Unsee
    - 더 나은 UX/UI를 고민해볼 수 있는 웹 사이트
- 학문으로서의 UX & UI
    - UX와 UI는 단순히 누군가의 직감에 의해서 결정되는 것이 아님
    - 하나의 학문으로서 연구되고 있는 분야이며 심리학과도 밀접한 연관이 있음
    - UX/UI 그리고 HCI
        - GUI : 유저가 보는 일반적인 시각적인 디자인
        - UI : 유저가 보거나 듣는 등 비시각적인 부분까지 포함한 디자인
        - UX :
        - HCI(Human Computer Interactions) :
    - 점점 더 복잡해지는 기술과 반대로 점점 더 단순하고 대중화되어야 하는 유저에 대한 경험으로 인해 계속해서 연구되는 중요한 분야
    - 예술에 정답이 없듯, 디자인에도 정답이 정해져 있지 않음
    - 전 세계의 많은 디자이너 또는 연구자들이 데이터에 기반해서 연구한 다양한 가이드 존재
    - ex. Apple의 UI 디자인 원칙 ([https://developer.apple.com/kr/design/tips/](https://developer.apple.com/kr/design/tips/))

### 1.3. Prototyping

- Software prototyping
    - 애플리케이션의 프로토타입을 만드는 것
    - 개발 중인 소프트웨어 프로그램의 완성되기 전 버전을 만드는 것
    - 한 번에 완성 버전이 나올 수 없기에 중간마다 현재 상태를 체크하는 과정
- Prototyping Tool
    - UI/UX 디자인을 prototyping하기 위한 도구는 굉장히 많고 빠른 패러다임의 변화로 인해 치열한 경쟁이 계속되고 있음
    - 이전까지는 Sketch라는 툴이 굉장히 많이 사용되었지만, 현재는 Figma라는 툴이 약 70%의 시장 점유율을 보이고 있음
- Figma
    - 인터페이스 디자인을 위한 협업 웹 어플리케이션 (2012년 출시)
    - 협업에 중점을 두면서 UI/UX 설계에 초점을 맞춤
- Why Figma?
    - 웹 기반 시스템을 가짐 (웹 환경에서 동작)
        - 매우 가벼운 환경에서 실행 가능, 모든 작업 내역이 웹에 저장됨
    - 실시간으로 팀원들이 협업할 수 있는 기능 제공
    - 직관적이고 다양한 디자인 툴 제공
    - Figma 사용자들이 만든 다양한 플러그인 존재 (ex. VSCode의 확장 프로그램 등)
    - 대부분의 기능을 무료로 사용할 수 있음
- Figma 성공의 이유
    - 성능의 희생을 일부 감수하고 웹 기반으로 원활한 협업이 이루어지도록 함
    - 기존 서비스들의 모든 불필요한 과정을 생략하고 디자인 그 자체에만 집중할 수 있게 함
    - 이를 따라잡기 위해 시장 업계 1위 Adobe도 Adobe XD라는 프로그램을 앞세우며 많은 노력을 했지만 경쟁이 불가함을 인정한 Adobe는 결국 2022년 9월 28조원에 Figma 인수
- 프로젝트를 시작하기 전에
    - 개발부터 시작하지 말고 반드시 충분한 기획을 거칠 것
    - 우리가 완성하고자 하는 대략적인 모습을 그려보는 과정이 필요 (프로토타입)
    - 이러한 과정을 통해서 기획에서 빠진 화면이나 API 등을 확인할 수 있음
    - 설계와 기획이 끝난 후 개발을 시작해야 체계적인 진행이 가능함
- 프로젝트와 협업
    - 협업은 프로젝트와 팀이 성공하기 위한 토대
    - 어떻게 효과적으로 잘 협업할 수 있는지 다양한 방법과 도구를 찾아보고 학습하며 여러 프로젝트를 경험하는 과정이 반드시 필요

## 2. Vue Router

### 2.1. Routing

- Routing
    - 네트워크에서 경로를 선택하는 프로세스
    - 웹 서비스에서의 라우팅
        - 유저가 방문한 URL에 대해 적절한 결과를 응답하는 것
    - ex. `/articles/index/`에 접근하면 articles의 index에 대한 결과를 보내줌
- Routing in SSR
    - 서버가 모든 라우팅을 통제
    - URL로 요청이 들어오면 응답으로 완성된 HTML 제공
        - 장고로 보낸 요청의 응답 HTML은 완성본인 상태였음
    - 결론적으로, Routing(URL)에 대한 결정권을 서버가 가짐
- Routing in SPA / CSR
    - 서버는 하나의  HTML(index.html)만을 제공
    - 이후에 모든 동작은 하나의 HTML 문서 위에서 자바스크립트 코드 활용
        - DOM을 그리는 데 필요한 추가적인 데이터가 있다면 axios와 같은 AJAX 요청을 보낼 수 있는 도구를 사용하여 데이터를 가져오고 처리
        - 즉, 하나의 URL만 가질 수 있음
- Why Routing?
    - 그럼 동작에 따라 URL이 반드시 바뀌어야 하나?
        - 그렇지는 않다! 단, 유저의 사용성 관점에서는 필요함
    - Routing이 없다면
        - 유저가 URL을 통한 페이지의 변화를 감지할 수 없음
        - 페이지가 무엇을 렌더링 중인지에 대한 상태를 알 수 없음
            - 새로고침 시 처음 페이지로 돌아감
            - 링크를 공유할 시 처음 페이지만 공유 가능
        - 브라우저의 뒤로 가기 기능을 사용할 수 없음

### 2.2. Vue Router

- Vue Router
    - Vue의 공식 라우터
    - SPA 상에서 라우팅을 쉽게 개발할 수 있는 기능 제공
    - 라우트(routes)에 컴포넌트를 매핑한 후, 어떤 URL에서 렌더링 할 지 알려줌
        - 즉, SPA를 MPA처럼 URL 이동하면서 사용 가능
            - MPA (Multiple Page Application)
                - 여러 개의 페이지로 구성된 어플리케이션
                - SSR 방식으로 렌더링
        - SPA의 단점 중 하나인 URL이 변경되지 않는 문제 해결
- Vue Router 시작하기
    - Vuex와 같은 방식으로 설치 및 반영
        - `vue create vue-router-app` : Vue 프로젝트 생성
        - `cd vue-router-app` : 디렉토리 이동
        - `vue add router` : Vue CLI를 통해 router plugin 적용
        - 기존에 프로젝트를 진행하고 있던 도중에 router를 추가하게 되면 App.vue를 덮어쓰므로 필요한 경우 명령을 실행하기 전에 파일을 백업해두어야 함
    - history mode 사용 여부 → yes
        - history mode
            - 브라우저의 History API를 활용한 방식
                - 새로고침 없이 URL 이동 기록을 남길 수 있음
            - 우리에게 익숙한 URL 구조로 사용 가능
                - ex. http://localhost:8080/index
            - [참고] History mode를 사용하지 않으면 디폴트 값인 hash mode로 설정됨 (`#`을 통해 URL을 구분하는 방식)
                - ex. http://localhost:8080#index
    - App.vue
        - router-link 요소 및 router-view가 추가됨
          
            ```jsx
            <template>
              <div id="app">
                <nav>
                  <router-link to="/">Home</router-link> |
                  <router-link to="/about">About</router-link>
                </nav>
                <router-view/>
              </div>
            </template>
            ```
        
    - 생성 확인
        - router/index.js 생성
        - views 폴더 생성
    - 서버 실행
- router-link
    - a 태그와 비슷한 기능 → URL을 이동시킴
        - routes에 등록된 컴포넌트와 매핑
        - 히스토리 모드에서 router-link는 클릭 이벤트를 차단하여 a 태그와 달리 브라우저가 페이지를 다시 로드하지 않도록 함
    - 목표 경로는 `to` 속성으로 지정
    - 기능에 맞게 HTML에서 a 태그로 rendering되지만, 필요에 따라 다른 태그로 바꿀 수 있음
- router-view
    - 주어진 URL에 대해 일치하는 컴포넌트를 렌더링하는 컴포넌트
    - 실제 component가 DOM에 부착되어 보이는 자리를 의미
    - router-link를 클릭하면 routes에 매핑된 컴포넌트를 렌더링
    - 장고에서의 block tag와 비슷함
        - App.vue는 base.html의 역할
        - router-view는 block 태그로 감싼 부분
- src/router/index.js
    - 라우터에 관련된 정보 및 설정이 작성되는 곳
    - 장고에서의 urls.py에 해당
    - routes에 URL과 컴포넌트를 매핑
    - 장고와 비교
      
        ```jsx
        const routes = [
          {
            path: '/',
            name: 'home',
            component: HomeView
          },
        ]
        ```
        
        ```python
        urlpatterns = [
            path('', views.home, name='home'),
        ]
        ```
    
- src/Views
    - router-view에 들어갈 component 작성
    - 기존에 컴포넌트를 작성하던 곳은 components 폴더 뿐이었지만 이제 두 폴더로 나뉘어짐
    - 각 폴더 안의 .vue 파일들이 기능적으로 다른 것은 아님
    - 폴더별 컴포넌트 배치는 다음과 같이 진행 권장 (규약은 아님)
        - views/
            - routes에 매핑되는 컴포넌트
                - 즉, <router-view>의 위치에 렌더링되는 컴포넌트를 모아두는 폴더
            - 다른 컴포넌트와 구분하기 위해 View로 끝나도록 만드는 것을 권장
            - ex. App 컴포넌트 내부의 AboutView & HomeView 컴포넌트
        - components/
            - routes에 매핑된 컴포넌트의 하위 컴포넌트를 모아두는 폴더
            - ex. HomeView 컴포넌트 내부의 HelloWorld 컴포넌트

### 2.3. Vue Router 실습

- 주소를 이동하는 2가지 방법
    - 선언적 방식 네비게이션
    - 프로그래밍 방식 네비게이션
- 선언적 방식 네비게이션
    - router-link의 `to` 속성으로 주소 전달
        - routes에 등록된 주소와 매핑된 컴포넌트로 이동
        
        ```jsx
        // App.vue
        
        <template>
          <div id="app">
            <nav>
              <router-link to="/">Home</router-link> |
              <router-link to="/about">About</router-link>
            </nav>
            <router-view/>
          </div>
        </template>
        ```
        
    - 동적인 값을 사용하기 때문에 v-bind를 사용해야 정상적으로 작동
      
        ```jsx
        <template>
          <div id="app">
            <nav>
              <router-link :to="{ name: 'home' }">Home</router-link> |
              <router-link :to="{ name: 'about' }">About</router-link> |
            </nav>
            <router-view/>
          </div>
        </template>
        ```
    
- Named Routes
    - 이름을 가지는 routes
        - 장고에서 path 함수의 name 인자의 활용과 같은 방식
        
        ```jsx
        // router/index.js
        
        const routes = [
          {
            path: '/',
            name: 'home',
            component: HomeView
          },
        ]
        ```
    
- 프로그래밍 방식 네비게이션
    - Vue 인스턴스 내부에서 라우터 인스턴스에 `$router`로 접근할 수 있음
    - 다른 URL로 이동하려면 `this.$router.push`를 사용
        - history stack에 이동할 URL을 넣는(push) 방식
        - history stack에 기록이 남기 때문에 사용자가 브라우저의 뒤로 가기 버튼을 클릭하면 이전 URL로 이동할 수 있음
    - 결국 <router-link :to=”…”>를 클릭하는 것과 `$router.push(…)`를 호출하는 것은 같은 동작
    - 동작 원리는 선언적 방식과 같음
      
        ```jsx
        // AboutView.vue
        
        <template>
          <div class="about">
            <h1>This is an about page</h1>
            <router-link :to="{ name: 'home' }">홈으로!</router-link>
            <button @click="toHome">홈으로!</button>
          </div>
        </template>
        
        <script>
        export default {
          name: 'AboutView',
          methods: {
            toHome() {
              this.$router.push({ name: 'home' })
            }
          }
        }
        </script>
        ```
    
- Dynamic Route Matching
    - 동적 인자 전달
        - URL의 특정 값을 변수처럼 사용할 수 있음
        - ex. 장고에서의 variable routing
    - HelloView.vue 작성 및 route 추가
    - route를 추가할 때 동적 인자를 명시
      
        ```jsx
        // router/index.js
        
        import HelloView from '@/views/HelloView'
        
        const routes = [
          {
            path: '/hello/:userName',
            name: 'hello',
            component: HelloView
          }
        ]
        ```
        
        ```jsx
        // views/HelloView.vue
        
        <template>
          <div>
          </div>
        </template>
        
        <script>
        export default {
          name: 'HelloView',
        }
        </script>
        ```
        
    - `$route.params`로 변수에 접근 가능
      
        ```jsx
        // views/HelloView.vue
        
        <template>
          <div>
            <h1>hello, {{ this.$route.params.userName }}</h1>
          </div>
        </template>
        
        <script>
        export default {
          name: 'HelloView',
        }
        </script>
        ```
        
    - 다만 HTML에서 직접 사용하기보다는 data에 넣어서 사용하는 것을 권장
      
        ```jsx
        // views/HelloView.vue
        
        <template>
          <div>
            <h1>hello, {{ userName }}</h1>
          </div>
        </template>
        
        <script>
        export default {
          name: 'HelloView',
          data() {
            return {
              userName: this.$route.params.userName
            }
          }
        }
        </script>
        ```
    
- Dynamic Route Matching - 선언적 방식 네비게이션
    - App.vue에서 harry에게 인사하는 페이지로 이동
    - params를 이용하여 동적 인자 전달 가능
      
        ```jsx
        // App.vue
        
        <template>
          <div id="app">
            <nav>
              <router-link :to="{ name: 'home' }">Home</router-link> |
              <router-link :to="{ name: 'about' }">About</router-link> |
              <router-link :to="{ name: 'hello', params: { userName: 'harry' }}">Hello</router-link> |
            </nav>
            <router-view/>
          </div>
        </template>
        ```
    
- Dynamic Route Matching - 프로그래밍 방식 네비게이션
    - AboutView에서 데이터를 입력 받아 HelloView로 이동하여 입력받은 데이터에게 인사하기
      
        ```jsx
        // AboutView.vue
        
        <template>
          <div class="about">
            ...
            <input
              type="text"
              @keyup.enter="goToHello"
              v-model="inputData"
            >
          </div>
        </template>
        
        <script>
        export default {
          name: 'AboutView',
          data() {
            return {
              inputData: null
            }
          },
          methods: {
            ...
            goToHello() {
              this.$router.push({ name: 'hello', params: { userName: this.inputData }})
            }
          }
        }
        </script>
        ```
    
- route에 컴포넌트를 등록하는 다른 방법
    - router/index.js에 컴포넌트를 등록하는 또다른 방식이 주어지고 있음 (about)
    - 기존 방식
      
        ```jsx
        // router/index.js
        
        import HomeView from '../views/HomeView.vue'
        
        const routes = [
          {
            path: '/',
            name: 'home',
            component: HomeView
          },
        ]
        ```
        
    - lazy-loading
      
        ```jsx
        // router/index.js
        
        const routes = [
          {
            path: '/about',
            name: 'about',
            component: () => import('../views/AboutView.vue')
          },
        ]
        ```
    
- lazy-loading
    - 모든 파일을 한 번에 로드하려고 하면 모든 걸 다 읽는 시간이 매우 오래 걸림
    - 미리 로드를 하지 않고 특정 route에 방문할 때 매핑된 컴포넌트의 코드를 로드하는 방식을 활용할 수 있음
        - 모든 파일을 한 번에 로드하지 않아도 되기 때문에 최초에 로드하는 시간이 빨라짐
        - 당장 사용하지 않을 컴포넌트는 먼저 로드하지 않는 것이 핵심

## 3. Navigation Guard

- 네비게이션 가드의 종류
    - 전역 가드 : 어플리케이션 전역에서 동작
    - 라우터 가드 : 특정 URL에서만 동작
    - 컴포넌트 가드 : 라우터 컴포넌트 안에 정의

### 3.1. 전역 가드

- Global Before Guard
    - 다른 URL 주소로 이동할 때 항상 실행
    - router/index.js에 `router.beforeEach()`를 사용하여 설정
    - 콜백 함수의 값으로 다음과 같이 3개의 인자를 받음
        - `to` : 이동할 URL 정보가 담긴 route 객체
        - `from` : 현재 URL 정보가 담긴 route 객체
        - `next` : 지정한 URL로 이동하기 위해 호출하는 함수
            - 콜백 함수 내부에서 반드시 한 번만
    - URL이 변경되며 화면이 전환되기 전 `router.beforeEach()`가 호출됨
        - 화면이 전환되지 않고 대기 상태가 됨
    - 변경된 URL로 라우팅하기 위해서는 `next()`를 호출해줘야 함
- Global Before Guard 실습
    - About으로 이동해보기
        - to에는 이동할 URL인 about에 대한 정보가, from에는 현재 url인 home에 대한 정보가 들어있음
- Login 여부에 따른 라우팅 처리
    - Login이 되어 있지 않다면 Login 페이지로 이동하는 기능 추가
    - HelloView에 로그인을 해야만 접근할 수 있도록 만들어 보기
    - isLoggedIn이 false인 경우 (비로그인 상태에서)
    - Home → Login으로 이동했는데 콘솔 창에 log가 2개 찍힌 이유
    - /hello/:userName 페이지를 제외하고는 전역 가드에서 기존 주소로 이동하기 때문에 정상적으로 작동
    - 로그인이 필요한 페이지에 추가하면 비로그인 시 해당 페이지에 접근 불가
      
        ```jsx
        
        ```
        
    - 만약 view가 여러개라면 모두 추가해야 할까?
        - 반대로 로그인하지 않아도 되는 페이지들을 모아 둘 수도 있음

### 3.2. 라우터 가드

- 라우터 가드
    - 전체 route가 아닌 특정 route에 대해서만 가드를 설정하고 싶을 때 사용
    - `beforeEnter()`
        - route에 진입했을 때 실행
        - 라우터를 등록한 위치에 추가
        - 단 매개변수, 쿼리, 해시 값이 변경될 때는 실행되지 않고 다른 경로에서 탐색할 때만 실행됨
        - 콜백 함수는 to, from, next를 인자로 받음
- Login 여부에 따른 라우팅 처리
    - 이미 로그인되어 있다면 HomeView로 이동하기
        - 라우터 가드 실습을 위해 전역 가드 실습코드는 주석처리

### 3.3. 컴포넌트 가드

- 컴포넌트 가드
    - 특정 컴포넌트 내에서 가드를 지정하고 싶을 때 사용
    - `beforeRouter
- Params 변화 감지
    - about에서 jun에게 인사하는 페이지로 이동
        - URL은 변하지만 페이지는 변화하지 않음
    - 변화하지 않는 이유
        - 컴포넌트가 재사용되었기 때문
        - 기존 컴포넌트를 지우고 새로 만드는 것보다 효율적
            - 단, lifecycle hook이 호출되지 않음
            - 따라서 `$route.params`에 있는 데이터를 새로 가져오지 않음
    - `beforeRouteUpdate()`를 사용해서 처리
        - userName을 이동할 params에 있는 userName으로 재할당
        
        ```jsx
        
        ```
        

### 3.4. 404 Not Found

- 404 Not Found
    - 사용자가 요청한 리소스가 존재하지 않을 때 응답
      
        ```jsx
        // views/NotFound404.vue
        ```
        
        ```jsx
        // router/index.js
        ```
    
- 형식은 유효하지만 특정 리소스를 찾을 수 없는 경우
    - /dog/abc에 접속
- 404 Not Found
    - 이전처럼 메시지를 바꿀 수도 있지만 axios 요청이 실패할 경우 404 페이지로 이동시킬 수도 있음

## 4. Articles app with Vue

- 개요
    - 지금까지 배운 내용들을 종합하여 장고에서 만들었던 게시판 만들기
    - 구현 기능
        - Index
        - Create
        - Detail
        - Delete
        - 404
    - 컴포넌트 구성
        - App.vue
            - router-view : dddd
- 사전 준비

### 4.1. Index

- Index 구현
    - state
    - 게시글의 필드는 id, 제목, 내용, 생성일자
    - DB의 AUTO INCREMENT를 표현하기 위해 article_id를 추가로 정의해줌 (다음 article의 id로 사용 예정)

### 4.2. Create

- 

```jsx
// 지금은 detail view가 마지막에 있어서
  // 어차피 detail 안에서 getArticleById 실행되고
  // NotFound404로 연결하기 때문에 아래 없이도 404 페이지 잘 뜬다.
  // 이 경우엔 그렇지만 일반적으로는 있어야 한다!
```